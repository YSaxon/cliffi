#include <stdio.h>
#include <stdlib.h>
#include "library_path_resolver.h"
#include "argparser.h"
#include "invoke_handler.h"
#include "return_formatter.h"



int main(int argc, char* argv[]) {
    if (argc < 4) {
        fprintf(stderr, "Usage: %s <library> <return_type> <function_name> [<args>...]\n", argv[0]);
        return 1;
    }

    // Step 1: Resolve the library path
    char* library_path = resolve_library_path(argv[1]);
    if (!library_path) {
        fprintf(stderr, "Error: Unable to resolve library path for %s\n", argv[1]);
        return 1;
    }

    // Update the library path in argv for consistent parsing
    argv[1] = library_path;

    // Step 2: Parse command-line arguments
    FunctionCallInfo* call_info = parse_arguments(argc, argv);
    if (!call_info) {
        fprintf(stderr, "Error: Failed to parse arguments\n");
        free(library_path); // Clean up library path
        return 1;
    }

    ArgInfo* out_return_value = malloc(sizeof(ArgInfo)); // Allocate memory for the return value
    // if (call_info->return_type != TYPE_VOID) { //Autogenerated code. Is this necessary?
    //     out_return_value = malloc(sizeof(ArgInfo));
    //     if (!out_return_value) { // is this necessary?
    //         fprintf(stderr, "Error: Failed to allocate memory for return value\n");
    //         free(library_path); // Clean up library path
    //         freeFunctionCallInfo(call_info); // Clean up call_info
    //         return 1;
    //     }
    // }

    // Step 2.5 (optional): Print the parsed function call info
    printf("Parsed function call info:\n");
    log_function_call_info(call_info);

    // Step 3: Invoke the specified function
    int invoke_result = invoke_dynamic_function(call_info, out_return_value);
    if (invoke_result != 0) {
        fprintf(stderr, "Error: Function invocation failed\n");
    }

    format_and_print_return_value(out_return_value);

    // Clean up
    free(library_path); // Free the resolved library path
    freeFunctionCallInfo(call_info); // Assuming this function exists for cleanup

    if (out_return_value) { //is this necessary?
        free(out_return_value); // Free the return value
    }

    return invoke_result;
}
